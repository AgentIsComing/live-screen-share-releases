# Live Screen Share Desktop

Desktop app for low-latency streaming with WebRTC.

## What this version adds
- Desktop app (Electron) for both host and viewer
- Host source can be:
  - Display/window capture from Electron desktop sources
  - OBS Virtual Camera device
- Audio routing options:
  - Display system audio
  - Selected audio input device (best for OBS via virtual cable)
  - Both
- Configurable ICE servers (for STUN/TURN)

## Install
```bash
npm install
```

## Run locally
1. Start signaling backend:
```bash
npm run start:signal
```
2. Start app:
```bash
npm run start:app
```

## No server hardware required (public internet from your PC)
You can expose your local signaling server from your own desktop using bundled Cloudflare Tunnel.

1. Keep signaling running: `npm run start:signal`
2. Install `cloudflared` (one-time)
3. Run:
```bash
npm run start:public-signal
```
4. It prints a public URL like `https://random-name.trycloudflare.com`
5. In both host and viewer app instances, set:
`Signaling URL = wss://random-name.trycloudflare.com/signal`

Or click `Auto-fill from Cloudflare Tunnel` in the app after the tunnel starts.

Fallback only (may show anti-abuse password page):
```bash
npm run start:public-signal-lt
```

This means your desktop is still the source machine, but no VPS is needed.

## Fix for "not capturing screen"
In Host mode:
1. Set `Video source = Display/Window capture`
2. Click `Refresh devices`
3. Pick a source in `Display/window source`
4. Click `Start hosting`

## OBS Virtual Screen workflow
If you want OBS output as streamed video:
1. In OBS: start `Virtual Camera`
2. Host mode: set `Video source = OBS Virtual Camera device`
3. Choose `OBS Virtual Camera` in `Camera device`
4. Click `Start hosting`

## Audio workflow (your requirement)
Goal: friend hears OBS, you still hear regular desktop audio.

Best method:
1. Install VB-CABLE or VoiceMeeter.
2. Route OBS monitor/output mix to that virtual cable.
3. Host mode: `Audio mode = Audio input device only`.
4. Select the virtual cable in `Audio input device`.

Now the app sends OBS mix to friend, while your desktop playback can stay on your normal speakers/headset.

## Different networks reliability
If connection still fails between homes/networks, add TURN in `ICE servers (JSON)`.

Example:
```json
[
  { "urls": "stun:stun.l.google.com:19302" },
  {
    "urls": "turn:turn.example.com:3478",
    "username": "user",
    "credential": "pass"
  }
]
```

## Files
- `electron/main.js` desktop app window + desktop capture source listing
- `electron/preload.js` safe API bridge
- `renderer/index.html` app UI
- `renderer/app.js` host/view + capture + signaling logic
- `server.js` signaling backend

## Auto Update Setup (Private Source Repo + Public Releases Repo)
Use this model if you want your code repo private but your friend to auto-update without you sending files.

### 1. Keep your source repo private
Push this project to your private repo (the one you already have).

### 2. Create a second PUBLIC GitHub repo for releases only
Create a new public repo, for example:
- `AgentIsComing/live-screen-share-releases`

Do not put your source code there. It will only hold installer assets generated by `electron-builder`.

### 3. Set release env vars before publishing
In PowerShell on your build PC:

```powershell
$env:RELEASE_OWNER="AgentIsComing"
$env:RELEASE_REPO="live-screen-share-releases"
$env:GH_TOKEN="YOUR_GITHUB_TOKEN"
```

Token requirements:
- Classic token with `repo` scope (simplest), or
- Fine-grained token with contents/releases write access to the public releases repo.

### 4. Build installer for first install
```powershell
npm run build:installer
```
Send the generated NSIS installer from `dist/` to your laptop once and install it there.

### 5. Publish every new update
1. Bump `version` in `package.json` (must be higher than previous).
2. Run:

```powershell
npm run release:public
```

This uploads new installer + `latest.yml` to the public releases repo.
Installed clients will detect and download updates automatically.

### 6. In-app manual check
Use the `Check app updates` button in the app to force a check.

### Notes
- Auto-update works from installed NSIS builds, not from portable zip builds.
- Keep release assets public for tokenless client updates.
## 5-digit Join Codes (Cloudflare Worker)
You can now join by short code instead of sharing the full signaling URL.

### Deploy the code service once
1. Authenticate Wrangler:
```bash
npx wrangler whoami
```
If not logged in:
```bash
npx wrangler login
```

2. Create KV namespace for codes:
```bash
npm run code-service:kv:create
```

3. Open `cloudflare/join-code-service/wrangler.toml` and paste the KV `id` and `preview_id`.

4. Deploy Worker:
```bash
npm run code-service:deploy
```

5. Copy Worker URL (example `https://live-screen-share-code-service.<subdomain>.workers.dev`).

### Use in the app
1. On both host and viewer apps, set `Code service URL` to your Worker URL.
2. Host clicks `Start backend (signal+tunnel)`.
3. Host clicks `Generate code (host)` and sends the 5-digit code.
4. Viewer enters code and clicks `Use code (viewer)`.
5. Viewer clicks `Connect as viewer`.

Code entries expire automatically (default ~15 minutes).

## Background Auto-Update Service (Windows Service)
This project now supports a true background updater service (option 2) so updates can be downloaded while the app is closed.

### Install the service (run as Administrator)
```powershell
npm run service:install
```

### Remove the service
```powershell
npm run service:uninstall
```

### How it works
- Service name: `LiveScreenShareUpdaterService`
- Checks GitHub releases every 15 minutes
- Downloads the latest setup `.exe` in the background
- If app is closed: applies update silently
- If app is open: app shows "Background update ready" and user can click `Check app updates` to install now

### Notes
- This service currently uses local Node runtime via `node-windows`.
- Install service once per PC (host/viewer machines that should self-update).
